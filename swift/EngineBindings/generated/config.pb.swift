// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Khiin_Proto_InputMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case imUnspecified // = 0
  case imContinuous // = 1
  case imBasic // = 2
  case imPro // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .imUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .imUnspecified
    case 1: self = .imContinuous
    case 2: self = .imBasic
    case 3: self = .imPro
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .imUnspecified: return 0
    case .imContinuous: return 1
    case .imBasic: return 2
    case .imPro: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Khiin_Proto_InputMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Khiin_Proto_InputMode] = [
    .imUnspecified,
    .imContinuous,
    .imBasic,
    .imPro,
  ]
}

#endif  // swift(>=4.2)

enum Khiin_Proto_DefaultPunctuation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case punctUnspecified // = 0
  case punctHalf // = 1
  case punctWhole // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .punctUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .punctUnspecified
    case 1: self = .punctHalf
    case 2: self = .punctWhole
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .punctUnspecified: return 0
    case .punctHalf: return 1
    case .punctWhole: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Khiin_Proto_DefaultPunctuation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Khiin_Proto_DefaultPunctuation] = [
    .punctUnspecified,
    .punctHalf,
    .punctWhole,
  ]
}

#endif  // swift(>=4.2)

struct Khiin_Proto_BoolValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Khiin_Proto_KeyConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var telexT2: String = String()

  var telexT3: String = String()

  var telexT5: String = String()

  var telexT6: String = String()

  var telexT7: String = String()

  var telexT8: String = String()

  var telexT9: String = String()

  var telexKhin: String = String()

  var altHyphen: String = String()

  var nasal: String = String()

  var dotAboveRight: String = String()

  var dotsBelow: String = String()

  var enableUppercaseNasal: Khiin_Proto_BoolValue {
    get {return _enableUppercaseNasal ?? Khiin_Proto_BoolValue()}
    set {_enableUppercaseNasal = newValue}
  }
  /// Returns true if `enableUppercaseNasal` has been explicitly set.
  var hasEnableUppercaseNasal: Bool {return self._enableUppercaseNasal != nil}
  /// Clears the value of `enableUppercaseNasal`. Subsequent reads from it will return its default value.
  mutating func clearEnableUppercaseNasal() {self._enableUppercaseNasal = nil}

  var useDigitsAsFallback: Khiin_Proto_BoolValue {
    get {return _useDigitsAsFallback ?? Khiin_Proto_BoolValue()}
    set {_useDigitsAsFallback = newValue}
  }
  /// Returns true if `useDigitsAsFallback` has been explicitly set.
  var hasUseDigitsAsFallback: Bool {return self._useDigitsAsFallback != nil}
  /// Clears the value of `useDigitsAsFallback`. Subsequent reads from it will return its default value.
  mutating func clearUseDigitsAsFallback() {self._useDigitsAsFallback = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enableUppercaseNasal: Khiin_Proto_BoolValue? = nil
  fileprivate var _useDigitsAsFallback: Khiin_Proto_BoolValue? = nil
}

struct Khiin_Proto_AppConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imeEnabled: Khiin_Proto_BoolValue {
    get {return _storage._imeEnabled ?? Khiin_Proto_BoolValue()}
    set {_uniqueStorage()._imeEnabled = newValue}
  }
  /// Returns true if `imeEnabled` has been explicitly set.
  var hasImeEnabled: Bool {return _storage._imeEnabled != nil}
  /// Clears the value of `imeEnabled`. Subsequent reads from it will return its default value.
  mutating func clearImeEnabled() {_uniqueStorage()._imeEnabled = nil}

  var keyConfig: Khiin_Proto_KeyConfiguration {
    get {return _storage._keyConfig ?? Khiin_Proto_KeyConfiguration()}
    set {_uniqueStorage()._keyConfig = newValue}
  }
  /// Returns true if `keyConfig` has been explicitly set.
  var hasKeyConfig: Bool {return _storage._keyConfig != nil}
  /// Clears the value of `keyConfig`. Subsequent reads from it will return its default value.
  mutating func clearKeyConfig() {_uniqueStorage()._keyConfig = nil}

  var inputMode: Khiin_Proto_InputMode {
    get {return _storage._inputMode}
    set {_uniqueStorage()._inputMode = newValue}
  }

  var telexEnabled: Khiin_Proto_BoolValue {
    get {return _storage._telexEnabled ?? Khiin_Proto_BoolValue()}
    set {_uniqueStorage()._telexEnabled = newValue}
  }
  /// Returns true if `telexEnabled` has been explicitly set.
  var hasTelexEnabled: Bool {return _storage._telexEnabled != nil}
  /// Clears the value of `telexEnabled`. Subsequent reads from it will return its default value.
  mutating func clearTelexEnabled() {_uniqueStorage()._telexEnabled = nil}

  var dottedKhin: Khiin_Proto_BoolValue {
    get {return _storage._dottedKhin ?? Khiin_Proto_BoolValue()}
    set {_uniqueStorage()._dottedKhin = newValue}
  }
  /// Returns true if `dottedKhin` has been explicitly set.
  var hasDottedKhin: Bool {return _storage._dottedKhin != nil}
  /// Clears the value of `dottedKhin`. Subsequent reads from it will return its default value.
  mutating func clearDottedKhin() {_uniqueStorage()._dottedKhin = nil}

  var autokhin: Khiin_Proto_BoolValue {
    get {return _storage._autokhin ?? Khiin_Proto_BoolValue()}
    set {_uniqueStorage()._autokhin = newValue}
  }
  /// Returns true if `autokhin` has been explicitly set.
  var hasAutokhin: Bool {return _storage._autokhin != nil}
  /// Clears the value of `autokhin`. Subsequent reads from it will return its default value.
  mutating func clearAutokhin() {_uniqueStorage()._autokhin = nil}

  var defaultPunctuation: Khiin_Proto_DefaultPunctuation {
    get {return _storage._defaultPunctuation}
    set {_uniqueStorage()._defaultPunctuation = newValue}
  }

  var easyCh: Khiin_Proto_BoolValue {
    get {return _storage._easyCh ?? Khiin_Proto_BoolValue()}
    set {_uniqueStorage()._easyCh = newValue}
  }
  /// Returns true if `easyCh` has been explicitly set.
  var hasEasyCh: Bool {return _storage._easyCh != nil}
  /// Clears the value of `easyCh`. Subsequent reads from it will return its default value.
  mutating func clearEasyCh() {_uniqueStorage()._easyCh = nil}

  var uppercaseNasal: Khiin_Proto_BoolValue {
    get {return _storage._uppercaseNasal ?? Khiin_Proto_BoolValue()}
    set {_uniqueStorage()._uppercaseNasal = newValue}
  }
  /// Returns true if `uppercaseNasal` has been explicitly set.
  var hasUppercaseNasal: Bool {return _storage._uppercaseNasal != nil}
  /// Clears the value of `uppercaseNasal`. Subsequent reads from it will return its default value.
  mutating func clearUppercaseNasal() {_uniqueStorage()._uppercaseNasal = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Khiin_Proto_InputMode: @unchecked Sendable {}
extension Khiin_Proto_DefaultPunctuation: @unchecked Sendable {}
extension Khiin_Proto_BoolValue: @unchecked Sendable {}
extension Khiin_Proto_KeyConfiguration: @unchecked Sendable {}
extension Khiin_Proto_AppConfig: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "khiin.proto"

extension Khiin_Proto_InputMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IM_UNSPECIFIED"),
    1: .same(proto: "IM_CONTINUOUS"),
    2: .same(proto: "IM_BASIC"),
    3: .same(proto: "IM_PRO"),
  ]
}

extension Khiin_Proto_DefaultPunctuation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUNCT_UNSPECIFIED"),
    1: .same(proto: "PUNCT_HALF"),
    2: .same(proto: "PUNCT_WHOLE"),
  ]
}

extension Khiin_Proto_BoolValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoolValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Khiin_Proto_BoolValue, rhs: Khiin_Proto_BoolValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Khiin_Proto_KeyConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "telex_t2"),
    2: .standard(proto: "telex_t3"),
    3: .standard(proto: "telex_t5"),
    4: .standard(proto: "telex_t6"),
    5: .standard(proto: "telex_t7"),
    6: .standard(proto: "telex_t8"),
    7: .standard(proto: "telex_t9"),
    8: .standard(proto: "telex_khin"),
    9: .standard(proto: "alt_hyphen"),
    10: .same(proto: "nasal"),
    11: .standard(proto: "dot_above_right"),
    12: .standard(proto: "dots_below"),
    13: .standard(proto: "enable_uppercase_nasal"),
    14: .standard(proto: "use_digits_as_fallback"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.telexT2) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.telexT3) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.telexT5) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.telexT6) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.telexT7) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.telexT8) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.telexT9) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.telexKhin) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.altHyphen) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.nasal) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.dotAboveRight) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.dotsBelow) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._enableUppercaseNasal) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._useDigitsAsFallback) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.telexT2.isEmpty {
      try visitor.visitSingularStringField(value: self.telexT2, fieldNumber: 1)
    }
    if !self.telexT3.isEmpty {
      try visitor.visitSingularStringField(value: self.telexT3, fieldNumber: 2)
    }
    if !self.telexT5.isEmpty {
      try visitor.visitSingularStringField(value: self.telexT5, fieldNumber: 3)
    }
    if !self.telexT6.isEmpty {
      try visitor.visitSingularStringField(value: self.telexT6, fieldNumber: 4)
    }
    if !self.telexT7.isEmpty {
      try visitor.visitSingularStringField(value: self.telexT7, fieldNumber: 5)
    }
    if !self.telexT8.isEmpty {
      try visitor.visitSingularStringField(value: self.telexT8, fieldNumber: 6)
    }
    if !self.telexT9.isEmpty {
      try visitor.visitSingularStringField(value: self.telexT9, fieldNumber: 7)
    }
    if !self.telexKhin.isEmpty {
      try visitor.visitSingularStringField(value: self.telexKhin, fieldNumber: 8)
    }
    if !self.altHyphen.isEmpty {
      try visitor.visitSingularStringField(value: self.altHyphen, fieldNumber: 9)
    }
    if !self.nasal.isEmpty {
      try visitor.visitSingularStringField(value: self.nasal, fieldNumber: 10)
    }
    if !self.dotAboveRight.isEmpty {
      try visitor.visitSingularStringField(value: self.dotAboveRight, fieldNumber: 11)
    }
    if !self.dotsBelow.isEmpty {
      try visitor.visitSingularStringField(value: self.dotsBelow, fieldNumber: 12)
    }
    try { if let v = self._enableUppercaseNasal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._useDigitsAsFallback {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Khiin_Proto_KeyConfiguration, rhs: Khiin_Proto_KeyConfiguration) -> Bool {
    if lhs.telexT2 != rhs.telexT2 {return false}
    if lhs.telexT3 != rhs.telexT3 {return false}
    if lhs.telexT5 != rhs.telexT5 {return false}
    if lhs.telexT6 != rhs.telexT6 {return false}
    if lhs.telexT7 != rhs.telexT7 {return false}
    if lhs.telexT8 != rhs.telexT8 {return false}
    if lhs.telexT9 != rhs.telexT9 {return false}
    if lhs.telexKhin != rhs.telexKhin {return false}
    if lhs.altHyphen != rhs.altHyphen {return false}
    if lhs.nasal != rhs.nasal {return false}
    if lhs.dotAboveRight != rhs.dotAboveRight {return false}
    if lhs.dotsBelow != rhs.dotsBelow {return false}
    if lhs._enableUppercaseNasal != rhs._enableUppercaseNasal {return false}
    if lhs._useDigitsAsFallback != rhs._useDigitsAsFallback {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Khiin_Proto_AppConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ime_enabled"),
    2: .standard(proto: "key_config"),
    3: .standard(proto: "input_mode"),
    4: .standard(proto: "telex_enabled"),
    5: .standard(proto: "dotted_khin"),
    6: .same(proto: "autokhin"),
    7: .standard(proto: "default_punctuation"),
    8: .standard(proto: "easy_ch"),
    9: .standard(proto: "uppercase_nasal"),
  ]

  fileprivate class _StorageClass {
    var _imeEnabled: Khiin_Proto_BoolValue? = nil
    var _keyConfig: Khiin_Proto_KeyConfiguration? = nil
    var _inputMode: Khiin_Proto_InputMode = .imUnspecified
    var _telexEnabled: Khiin_Proto_BoolValue? = nil
    var _dottedKhin: Khiin_Proto_BoolValue? = nil
    var _autokhin: Khiin_Proto_BoolValue? = nil
    var _defaultPunctuation: Khiin_Proto_DefaultPunctuation = .punctUnspecified
    var _easyCh: Khiin_Proto_BoolValue? = nil
    var _uppercaseNasal: Khiin_Proto_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _imeEnabled = source._imeEnabled
      _keyConfig = source._keyConfig
      _inputMode = source._inputMode
      _telexEnabled = source._telexEnabled
      _dottedKhin = source._dottedKhin
      _autokhin = source._autokhin
      _defaultPunctuation = source._defaultPunctuation
      _easyCh = source._easyCh
      _uppercaseNasal = source._uppercaseNasal
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._imeEnabled) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._keyConfig) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._inputMode) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._telexEnabled) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._dottedKhin) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._autokhin) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._defaultPunctuation) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._easyCh) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._uppercaseNasal) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._imeEnabled {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._keyConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._inputMode != .imUnspecified {
        try visitor.visitSingularEnumField(value: _storage._inputMode, fieldNumber: 3)
      }
      try { if let v = _storage._telexEnabled {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._dottedKhin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._autokhin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._defaultPunctuation != .punctUnspecified {
        try visitor.visitSingularEnumField(value: _storage._defaultPunctuation, fieldNumber: 7)
      }
      try { if let v = _storage._easyCh {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._uppercaseNasal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Khiin_Proto_AppConfig, rhs: Khiin_Proto_AppConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._imeEnabled != rhs_storage._imeEnabled {return false}
        if _storage._keyConfig != rhs_storage._keyConfig {return false}
        if _storage._inputMode != rhs_storage._inputMode {return false}
        if _storage._telexEnabled != rhs_storage._telexEnabled {return false}
        if _storage._dottedKhin != rhs_storage._dottedKhin {return false}
        if _storage._autokhin != rhs_storage._autokhin {return false}
        if _storage._defaultPunctuation != rhs_storage._defaultPunctuation {return false}
        if _storage._easyCh != rhs_storage._easyCh {return false}
        if _storage._uppercaseNasal != rhs_storage._uppercaseNasal {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
